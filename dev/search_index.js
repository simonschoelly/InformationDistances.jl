var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = InformationDistances","category":"page"},{"location":"#InformationDistances","page":"Home","title":"InformationDistances","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [InformationDistances]","category":"page"},{"location":"#InformationDistances.ByteData","page":"Home","title":"InformationDistances.ByteData","text":"const ByteData = Union{Vector{UInt8}, Base.CodeUnits{UInt8, <: AbstractString}}\n\nEither a Vector of UInt8 or a Base.CodeUnit{UInt8} object. Compressors should be able to compress both of these types.\n\n\n\n\n\n","category":"type"},{"location":"#InformationDistances.AbstractCompressor","page":"Home","title":"InformationDistances.AbstractCompressor","text":"AbstractCompressor\n\nA compressor interface type that represent string compressors.\n\nMandatory methods\n\ncompressed_length( <: AbstractCompressor, ::InformationDistances.ByteData)\n\nOptional methods\n\ncompressed_lengths( <: AbstractCompressor, iter)\n\n\n\n\n\n","category":"type"},{"location":"#InformationDistances.CodecCompressor","page":"Home","title":"InformationDistances.CodecCompressor","text":"CodecCompressor{ <: TranscodingStreams.Codec} <: AbstractCompressor\n\nA compressor that uses a TranscodingStreams.Codec for compressing.\n\n\n\nCodecCompressor{C <: TranscodingStreams.Codec}(;kwargs...)\n\nCreate a CodecCompressor for the codec C with a additional keyword arguments passed to the constructor of that codec.\n\nExamples\n\njulia> using CodecXz: XzCompressor\n\njulia> CodecCompressor{XzCompressor}(; level=6)\nCodecCompressor{XzCompressor}(Base.Iterators.Pairs(:level => 6))\n\n\n\n\n\n","category":"type"},{"location":"#InformationDistances.LibDeflateCompressor","page":"Home","title":"InformationDistances.LibDeflateCompressor","text":"LibDeflateCompressor <: AbstractCompressor\n\nA compressor that uses a LibDeflate.jl for compressing.\n\n\n\nLibDeflateCompressor(;compresslevel=12)\n\nCreate a LibDeflateCompressor with compression level compresslevel.\n\nExamples\n\njulia> LibDeflateCompressor()\nLibDeflateCompressor(12)\n\njulia> LibDeflateCompressor(;compresslevel=8)\nLibDeflateCompressor(8)\n\n\n\n\n\n","category":"type"},{"location":"#InformationDistances.NormalizedCompressionDistance","page":"Home","title":"InformationDistances.NormalizedCompressionDistance","text":"NormalizedCompressionDistance{<: AbstractCompressor} <: Distances.PreMetric\n\nA normalized compression distance metric between two strings.\n\nThe metric is defined by d(x y) = fracZ(xy) - min(Z(x) Z(y)) max(Z(x) Z(y))\n\nwhere Z(x) is the length when compressing the string x with a certain compression codec.\n\n\n\nNormalizedCompressionDistance(, [compressor::AbstractCompressor])\n\nCreate a NormalizedCompressionDistance.\n\nArguments\n\ncompressor The compressor to use. If not specified,   CodecCompressor{CodecXz.XzCompressor}(;level=9; check=CodecXz.LZMA_CHECK_NONE) is used.\n\nExamples\n\njulia> d1 = NormalizedCompressionDistance()\nNormalizedCompressionDistance{CodecCompressor{CodecXz.XzCompressor}}(CodecCompressor{CodecXz.XzCompressor}(Base.Iterators.Pairs{Symbol,Signed,Tuple{Symbol,Symbol},NamedTuple{(:level, :check),Tuple{Int64,Int32}}}(:level => 9,:check => 0)))\n\njulia> d1(\"hello\", \"world\")\n0.07142857142857142\n\njulia> d2 = NormalizedCompressionDistance(LibDeflateCompressor())\nNormalizedCompressionDistance{LibDeflateCompressor}(LibDeflateCompressor(12))\n\njulia> d2(\"hello\", \"world\")\n0.5\n\n\n\n\n\n","category":"type"},{"location":"#InformationDistances.compressed_length-Tuple{InformationDistances.AbstractCompressor,AbstractString}","page":"Home","title":"InformationDistances.compressed_length","text":"compressed_length(compressor, s)\n\nThe number of resulting bytes when s is compressed with compressor.\n\nWhen implementing a subtype Compressor <: AbstractCompressor one should implement `compressed_length(compressor::Compressor, s::InformationDistances.ByteData)\n\nExamples\n\njulia> compressed_length(LibDeflateCompressor(), \"hello\")\n10\n\n\n\n\n\n","category":"method"},{"location":"#InformationDistances.compressed_lengths-Tuple{Any,Any}","page":"Home","title":"InformationDistances.compressed_lengths","text":"compressed_lengths(compressor, iter)\n\nCalculate for each s in iter the number of resulting bytes when s is compressed with compressor.\n\nImplementing this method for a specific subtype of AbstractCompressor might lead to some performance improvements as some compressors need to allocate some resources before compressing, therefore batch processing might lead to performance improvements as the resources have to be allocated only once.\n\nIt is recommended but not necessary to implement this method for a custom subtype Compressor <: AbstractCompressor. The method signature in that case should be compressed_lengths(compressor::Compressor, iter).\n\nAs Julia does not allow one to specify the eltype of an iterator, one should make at least sure, that the elements of iter can be of type InformationDistances.ByteData and optionally could also be of type AbstractString.\n\nExamples\n\njulia> compressed_lengths(LibDeflateCompressor(), [\"hello\", \"world\", \"!\"])\n3-element Array{Int64,1}:\n 10\n 10\n  6\n\n\n\n\n\n","category":"method"}]
}
